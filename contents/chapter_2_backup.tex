% !TEX root = ../main.tex

\chapter{在线推理模拟器的设计与优化}
在全局调度器的调度决策中，为了应用推理模拟器进行性能预测，存在一些与离线模拟器的不同点，这使得已有的模拟器工作难以满足在线调度的需求。
本章节对模拟器的语义和接口、状态管理抽象和状态同步的角度，分析在线模拟器面临的问题和设计选择。
整体架构图如(TODO!)所示

\section{语义和接口}
在线调度器的语义和接口与离线调度器有明显的不同(如图(TODO!))。
离线模拟器通常只需要在启动时指定系统配置和workload，通过事件循环模拟每个请求到达、实例调度等事件，最终离线的得到集群性能指标。
而在线调度器的核心接口是对单个请求在实例上的执行性能预测，每当新请求到达时模拟预测请求在每个实例可能的执行性能，返回关键指标来指导全局调度决策。

此外，在线服务中为了确保批处理行为与真实实例一致，需要状态同步接口完成与真实推理实例的状态同步。
推理实例状态进行同步的时刻包括新请求指派到推理实例时和每次批处理完成时。
对于前者，全局调度器只需要在完成调度决策后，将请求加入对应实例模拟器的等待队列。
而后者则需要通过实例调度器在完成批处理后，将当前批处理的调度器行为、执行结果和状态更新信息上报给全局调度器，以便在线模拟器进行状态修正和同步。
状态的同步包括KVCache的更新、调度到的请求和Token以及请求完成情况，以及实例调度器修改实例状态的特殊行为，
例如对请求的抢占和

\section{状态管理抽象}
由于语义和行为的不同，在线模拟器与离线模拟器对于状态的管理存在一定差异，如图(TODO!)。
离线模拟器的状态管理是线性的，每次调度决策都会确定性地导致状态的改变和推进，并且不会存在状态回退的情况；
而在线模拟器的状态管理则更为复杂。这是因为在线模拟器为了避免与推理实例的状态Diverge导致预测失真，
需要不断与推理实例进行状态同步，并在状态Diverge时进行状态修正。
模拟器实际维护的状态包含Ground Truth State和Predicted State两部分，其中Ground Truth State是实例当前，而Tentative State则是模拟器当前正在预测的状态。
(TODO!)

\section{状态同步}
在全局调度器中，模拟器维护的状态可能和推理实例真实状态发生不一致，因此需要两个组件之间的状态同步，这在离线模拟的场景中并不存在。
导致状态不一致有两个原因，首先是全局调度器和推理实例之间分布式系统的特性，会导致两者发生状态分离。
例如推理实例会并行地对新到达请求进行分词，对于先后到达的两个请求，可能后到达的短请求分词过程更快，比先到达的长请求更早加入到实例调度器的等待队列中。
这造成了两个组件之间队列的不保序，由于实例调度器先到先服务的特性，基于乱序的等待队列可能会导致模拟器做出完全不同的调度决策。

其次，推理实例中能够利用更多的自有信息，来做出特定的行为，这些信息需要让全局调度器感知。
一个简单的实例调度器的行为相对好预测，但是也有很多复杂的实例调度器设计，来特化对SLO的满足等。
简单调度器的决策例如判断请求是否终止，以及根据请求优先级、到达时间进行抢占。
复杂的调度器包含比较SLO来构建批处理等。

因此需要全局调度器与推理实例的状态同步，保证模拟器能够基于相同的起始状态进行性能预测，
并且能够后期扩展支持更复杂的实例调度器行为。一个详细的状态同步接口定义
